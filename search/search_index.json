{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pynajax","text":"<p>Welcome to <code>pynajax</code>, a GPU accelerated backend for pynapple built on top on jax. It offers a fast acceleration for the core pynapple functions using GPU. </p> <p>Warning</p> <p>This package is not meant to be used on its own. It should only be used through the pynapple API.</p>"},{"location":"#installation","title":"Installation","text":"<p>Run the following <code>pip</code> command in your virtual environment.</p> <p>For macOS/Linux users: <pre><code>pip install pynajax\n</code></pre></p> <p>For Windows users: <pre><code>python -m pip install pynajax\n</code></pre></p> <p>Alternatively, you can install pynapple and pynajax together.</p> <pre><code> pip install pynapple[jax]\n</code></pre>"},{"location":"#basic-usage","title":"Basic usage","text":"<p>To use pynajax, you need to change the pynapple backend using <code>nap.nap_config.set_backend</code>. See the example below : </p> <pre><code>import pynapple as nap\nimport numpy as np\nnap.nap_config.set_backend(\"jax\")\n\ntsd = nap.Tsd(t=np.arange(100), d=np.random.randn(100))\n\n# This will run on GPU or CPU depending on the jax installation\ntsd.convolve(np.ones(11)) \n</code></pre>"},{"location":"#benchmark","title":"Benchmark","text":"<p>This benchmark for the <code>convolve</code> function was run on a GPU.</p> <p></p> <p>See the documentation for others benchmarks.</p>"},{"location":"generated/gallery/","title":"Benchmarks","text":""},{"location":"generated/gallery/#benchmarks","title":"Benchmarks","text":"<p>Performance comparison between <code>pynajax</code> and the normal <code>pynapple</code> backend based on <code>numba</code>. The functions that have been optimized with <code>pynajax</code> are :</p> <ul> <li> <p><code>convolve</code></p> </li> <li> <p><code>bin_average</code></p> </li> <li> <p><code>threshold</code></p> </li> <li> <p><code>event_trigger_average</code></p> </li> <li> <p>filtering</p> </li> </ul> <p> bin_average </p> <p> convolve </p> <p> event_trigger_average </p> <p> filtering </p> <p> threshold </p> <p> Download all examples in Python source code: gallery_python.zip</p> <p> Download all examples in Jupyter notebooks: gallery_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/mg_execution_times/","title":"Computation times","text":"<p>00:29.802 total execution time for generated_gallery files:</p> <p>+-------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_benchmark_filtering (docs/examples/plot_benchmark_filtering.py)                                     | 00:29.802 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_benchmark_bin_average (docs/examples/plot_benchmark_bin_average.py)                               | 00:00.000 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_benchmark_convolve (docs/examples/plot_benchmark_convolve.py)                                        | 00:00.000 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_benchmark_event_trigger_average (docs/examples/plot_benchmark_event_trigger_average.py) | 00:00.000 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_benchmark_threshold (docs/examples/plot_benchmark_threshold.py)                                     | 00:00.000 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/plot_benchmark_bin_average/","title":"bin_average","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_benchmark_bin_average/#bin_average","title":"bin_average","text":"<pre><code>import numpy as np\nimport pynapple as nap\nimport jax.numpy as jnp\nfrom time import perf_counter\nimport matplotlib.pyplot as plt\n</code></pre> <p>Machine Configuration</p> <pre><code>import jax\nprint(jax.devices())\n</code></pre> <p>Out:</p> <pre><code>[CudaDevice(id=0)]\n</code></pre> <pre><code>def get_mean_perf_class(obj, ep, binsize):\n    n = 10\n    tmp = np.zeros(n)\n    for i in range(n):\n        t1 = perf_counter()\n        out = obj.bin_average(binsize, ep)\n        t2 = perf_counter()\n        tmp[i] = t2 - t1\n    return np.mean(tmp), np.std(tmp)\n\ndef benchmark_bin_average(binsize):\n    times = []\n    for T in np.arange(1000, 200000, 10000):\n        time_array = np.arange(T) / 2\n        data_array = np.arange(16 * T).reshape(T, 4, 2, 2)\n        starts = np.arange(1, T // 2 - 1, 20)\n        ends = np.arange(1, T // 2 - 1, 20) + 8\n\n        ep = nap.IntervalSet(start=starts, end=ends)\n        tsd = nap.TsdTensor(t=time_array, d=data_array)\n\n        res = tsd.bin_average(binsize, ep) # First call to compile\n        m, s = get_mean_perf_class(tsd, ep, binsize)\n        times.append([T, m, s])\n    return np.array(times)\n</code></pre> <p>Calling with numba</p> <pre><code>binsize = 7.0\n\nnap.nap_config.set_backend(\"numba\")\nnum_times = benchmark_bin_average(binsize)\n</code></pre> <p>Calling with jax</p> <pre><code>nap.nap_config.set_backend(\"jax\")\njax_times = benchmark_bin_average(binsize)\n</code></pre> <p>Out:</p> <pre><code>/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n</code></pre> <p>Figure</p> <pre><code>plt.figure()\nfor arr, label in zip(\n    [num_times, jax_times],\n    [\"numba backend\", \"pynajax backend\"],\n    ):\n    plt.plot(arr[:, 0], arr[:, 1], \"o-\", label=label)\n    plt.fill_between(arr[:, 0], arr[:, 1] - arr[:, 2], arr[:, 1] + arr[:, 2], alpha=0.2)\nplt.legend()\nplt.xlabel(\"Number of Time points\")\nplt.ylabel(\"Time (s)\")\nplt.title(\"Bin_average benchmark\")\nplt.show()\n</code></pre> <p></p> <p>Saving</p> <p>Total running time of the script: ( 0 minutes  22.491 seconds)</p> <p> Download Python source code: plot_benchmark_bin_average.py</p> <p> Download Jupyter notebook: plot_benchmark_bin_average.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_benchmark_convolve/","title":"convolve","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_benchmark_convolve/#convolve","title":"convolve","text":"<pre><code>import numpy as np\nimport pynapple as nap\nimport jax.numpy as jnp\nfrom time import perf_counter\nimport matplotlib.pyplot as plt\n</code></pre> <p>Machine Configuration</p> <pre><code>import jax\nprint(jax.devices())\n</code></pre> <p>Out:</p> <pre><code>[CudaDevice(id=0)]\n</code></pre> <pre><code>def get_mean_perf_class(obj, kernel):\n    n = 10\n    tmp = np.zeros(n)\n    for i in range(n):\n        t1 = perf_counter()\n        out = obj.convolve(kernel)\n        t2 = perf_counter()\n        tmp[i] = t2 - t1\n    return np.mean(tmp), np.std(tmp)\n\ndef benchmark_convolve(kernel):\n    times = []\n    for nd in range(10, 500, 50):\n        print(\"Dimensions \", nd)\n        t = np.arange(10000)\n        d = np.random.randn(10000, nd)\n        tsd = nap.TsdFrame(t=t, d=d)        \n        tsd2 = tsd.convolve(kernel) # First call to compile\n        m, s = get_mean_perf_class(tsd, kernel)\n        times.append([nd, m, s])\n    return np.array(times)\n</code></pre> <p>Calling with jax</p> <pre><code>nap.nap_config.set_backend(\"jax\")\njax_times = benchmark_convolve(jnp.ones(11))\n</code></pre> <p>Out:</p> <pre><code>Dimensions  10\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\nDimensions  60\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\nDimensions  110\nDimensions  160\nDimensions  210\nDimensions  260\nDimensions  310\nDimensions  360\nDimensions  410\nDimensions  460\n</code></pre> <p>Calling with numba</p> <pre><code>nap.nap_config.set_backend(\"numba\")\nnum_times = benchmark_convolve(np.ones(11))\n</code></pre> <p>Out:</p> <pre><code>Dimensions  10\nDimensions  60\nDimensions  110\nDimensions  160\nDimensions  210\nDimensions  260\nDimensions  310\nDimensions  360\nDimensions  410\nDimensions  460\n</code></pre> <p>Figure</p> <pre><code>plt.figure()\nfor arr, label in zip(\n    [num_times, jax_times],\n    [\"numba backend\", \"pynajax backend\"],\n    ):\n    plt.plot(arr[:, 0], arr[:, 1], \"o-\", label=label)\n    plt.fill_between(arr[:, 0], arr[:, 1] - arr[:, 2], arr[:, 1] + arr[:, 2], alpha=0.2)\nplt.legend()\nplt.xlabel(\"Number of Dimensions\")\nplt.ylabel(\"Time (s)\")\nplt.title(\"Convolve benchmark\")\nplt.savefig(\"../images/convolve_benchmark.png\")\nplt.show()\n</code></pre> <p></p> <p>Saving</p> <p>Total running time of the script: ( 0 minutes  11.107 seconds)</p> <p> Download Python source code: plot_benchmark_convolve.py</p> <p> Download Jupyter notebook: plot_benchmark_convolve.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_benchmark_event_trigger_average/","title":"event_trigger_average","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_benchmark_event_trigger_average/#event_trigger_average","title":"event_trigger_average","text":"<pre><code>import numpy as np\nimport pynapple as nap\nimport jax.numpy as jnp\nfrom time import perf_counter\nimport matplotlib.pyplot as plt\n</code></pre> <p>Machine Configuration</p> <pre><code>import jax\nprint(jax.devices())\n</code></pre> <p>Out:</p> <pre><code>[CudaDevice(id=0)]\n</code></pre> <pre><code>def get_mean_perf_class(tsg, tsd, ep, binsize):\n    n = 10\n    tmp = np.zeros(n)\n    for i in range(n):\n        t1 = perf_counter()\n        out = nap.compute_event_trigger_average(tsg, tsd, binsize, (binsize*10, binsize*10), ep)\n        t2 = perf_counter()\n        tmp[i] = t2 - t1\n    return np.mean(tmp), np.std(tmp)\n\ndef benchmark_event_trigger_average(binsize):\n    times = []\n    for T in np.arange(100000, 1000000, 100000):\n        time_array = np.arange(T) / 2\n        data_array = np.arange(16 * T).reshape(T, 4, 2, 2)\n        starts = np.arange(1, T // 2 - 1, 20)\n        ends = np.arange(1, T // 2 - 1, 20) + 8\n        ep = nap.IntervalSet(start=starts, end=ends)\n        tsd = nap.TsdTensor(t=time_array, d=data_array)\n        tsg = nap.TsGroup(\n            {i:nap.Ts(time_array[::2]) for i in range(10)}\n\n            )\n        sta = nap.compute_event_trigger_average(tsg, tsd, binsize, (binsize*10, binsize*10), ep)\n\n        m, s = get_mean_perf_class(tsg, tsd, ep, binsize)\n\n        times.append([T, m, s])\n    return np.array(times)\n</code></pre> <p>Calling with numba</p> <pre><code>binsize = 1.0\n\nnap.nap_config.set_backend(\"numba\")\nnum_times = benchmark_event_trigger_average(binsize)\n</code></pre> <p>Calling with jax</p> <pre><code>nap.nap_config.set_backend(\"jax\")\njax_times = benchmark_event_trigger_average(binsize)\n</code></pre> <p>Out:</p> <pre><code>/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n</code></pre> <p>Figure</p> <pre><code>plt.figure()\nfor arr, label in zip(\n    [num_times, jax_times],\n    [\"numba backend\", \"pynajax backend\"],\n    ):\n    plt.plot(arr[:, 0], arr[:, 1], \"o-\", label=label)\n    plt.fill_between(arr[:, 0], arr[:, 1] - arr[:, 2], arr[:, 1] + arr[:, 2], alpha=0.2)\nplt.legend()\nplt.xlabel(\"Number of Time points\")\nplt.ylabel(\"Time (s)\")\nplt.title(\"Event_trigger_average benchmark\")\nplt.show()\n</code></pre> <p></p> <p>Saving</p> <p>Total running time of the script: ( 0 minutes  53.678 seconds)</p> <p> Download Python source code: plot_benchmark_event_trigger_average.py</p> <p> Download Jupyter notebook: plot_benchmark_event_trigger_average.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_benchmark_filtering/","title":"filtering","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_benchmark_filtering/#filtering","title":"filtering","text":"<p>This notebook compare the jax implementation of Butterworth filter with scipy sosfiltfilt.</p> <p>Performances of the <code>'sinc'</code> mode can be found in the convolve benchmark as it is the function being called underneath.</p> <p>\u26a0\ufe0f Warning: We do not recommend using GPU for filtering as it is much slower for the moment compared to CPU.</p> <pre><code>import os\nimport numpy as np\nimport pynapple as nap\nfrom time import perf_counter\nimport matplotlib.pyplot as plt\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n</code></pre> <p>Machine Configuration</p> <pre><code>import jax\nprint(jax.devices())\n</code></pre> <p>Out:</p> <pre><code>[CpuDevice(id=0)]\n</code></pre> <pre><code>def get_mean_perf(tsd, mode, n=10):\n    tmp = np.zeros(n)\n    _ = nap.apply_lowpass_filter(tsd, 0.25 * tsd.rate, mode=mode)\n    for i in range(n):\n        t1 = perf_counter()\n        _ = nap.apply_lowpass_filter(tsd, 0.25 * tsd.rate, mode=mode)\n        t2 = perf_counter()\n        tmp[i] = t2 - t1\n    return [np.mean(tmp), np.std(tmp)]\n</code></pre>"},{"location":"generated/gallery/plot_benchmark_filtering/#increasing-number-of-time-points","title":"Increasing number of time points","text":"<pre><code>def benchmark_time_points(mode):\n    times = []\n    for T in np.arange(1000, 100000, 20000):\n        time_array = np.arange(T)/1000\n        data_array = np.random.randn(len(time_array))\n        startend = np.linspace(0, time_array[-1], T//100).reshape(T//200, 2)\n        ep = nap.IntervalSet(start=startend[::2,0], end=startend[::2,1])\n        tsd = nap.Tsd(t=time_array, d=data_array)#, time_support=ep)\n        times.append([T]+get_mean_perf(tsd, mode))\n    return np.array(times)\n</code></pre> <p>Calling with numba/scipy</p> <pre><code>nap.nap_config.set_backend(\"numba\")\ntimes_butter_scipy = benchmark_time_points(mode=\"butter\")\n</code></pre> <p>Calling with jax</p> <pre><code>nap.nap_config.set_backend(\"jax\")\ntimes_butter_jax = benchmark_time_points(mode=\"butter\")\n</code></pre> <p>Figure</p> <pre><code>plt.figure()\nfor arr, label in zip(\n    [times_butter_scipy, times_butter_jax],\n    [\"Butter (scipy)\", \"Butter (jax)\"],\n    ):\n    plt.plot(arr[:, 0], arr[:, 1], \"o-\", label=label)\n    plt.fill_between(arr[:, 0], arr[:, 1] - arr[:, 2], arr[:, 1] + arr[:, 2], alpha=0.2)\n\nplt.legend()\nplt.xlabel(\"Number of time points\")\nplt.ylabel(\"Time (s)\")\nplt.title(\"Butterworth filter low pass\")\n# plt.show()\n</code></pre> <p></p> <p>Out:</p> <pre><code>Text(0.5, 1.0, 'Butterworth filter low pass')\n</code></pre>"},{"location":"generated/gallery/plot_benchmark_filtering/#increasing-number-of-dimensions","title":"Increasing number of dimensions","text":"<pre><code>def benchmark_dimensions(mode):\n    times = []\n    T = 60000\n    for n in np.arange(1, 100, 20):\n        time_array = np.arange(T)/1000\n        data_array = np.random.randn(len(time_array), n)\n        startend = np.linspace(0, time_array[-1], T//100).reshape(T//200, 2)\n        ep = nap.IntervalSet(start=startend[::2,0], end=startend[::2,1])\n        tsd = nap.TsdFrame(t=time_array, d=data_array, time_support=ep)\n        times.append([n]+get_mean_perf(tsd, mode))\n    return np.array(times)\n</code></pre> <p>Calling with numba/scipy</p> <pre><code>nap.nap_config.set_backend(\"numba\")\ndims_butter_scipy = benchmark_dimensions(mode=\"butter\")\n</code></pre> <p>Calling with jax</p> <pre><code>nap.nap_config.set_backend(\"jax\")\ndims_butter_jax = benchmark_dimensions(mode=\"butter\")\n</code></pre> <p>Figure</p> <pre><code>plt.figure()\n\nfor arr, label in zip(\n    [dims_butter_scipy, dims_butter_jax],\n    [\"Butter (scipy)\", \"Butter (jax)\"],\n    ):\n    plt.plot(arr[:, 0], arr[:, 1], \"o-\", label=label)\n    plt.fill_between(arr[:, 0], arr[:, 1] - arr[:, 2], arr[:, 1] + arr[:, 2], alpha=0.2)\n\nplt.legend()\nplt.xlabel(\"Number of dimensions\")\nplt.ylabel(\"Time (s)\")\nplt.title(\"Butterworth filter low pass\")\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  29.802 seconds)</p> <p> Download Python source code: plot_benchmark_filtering.py</p> <p> Download Jupyter notebook: plot_benchmark_filtering.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_benchmark_threshold/","title":"threshold","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_benchmark_threshold/#threshold","title":"threshold","text":"<pre><code>import numpy as np\nimport pynapple as nap\nimport jax.numpy as jnp\nfrom time import perf_counter\nimport matplotlib.pyplot as plt\n</code></pre> <p>Machine Configuration</p> <pre><code>import jax\nprint(jax.devices())\n</code></pre> <p>Out:</p> <pre><code>[CudaDevice(id=0)]\n</code></pre> <pre><code>def get_mean_perf_class(obj):\n    n = 10\n    tmp = np.zeros(n)\n    for i in range(n):\n        t1 = perf_counter()\n        out = obj.threshold(0.0)\n        t2 = perf_counter()\n        tmp[i] = t2 - t1\n    return np.mean(tmp), np.std(tmp)\n\ndef benchmark_threshold():\n    times = []\n    for T in np.arange(500000, 1000000, 100000):\n        time_array = np.arange(T) / 2\n        data_array = np.random.randn(len(time_array))\n        starts = np.arange(1, T // 2 - 1, 20)\n        ends = np.arange(1, T // 2 - 1, 20) + 8\n\n        ep = nap.IntervalSet(start=starts, end=ends)\n        tsd = nap.Tsd(t=time_array, d=data_array, time_support=ep)\n\n        res = tsd.threshold(0.0) # First call to compile\n        m, s = get_mean_perf_class(tsd)\n        times.append([T, m, s])\n    return np.array(times)\n</code></pre> <p>Calling with numba</p> <pre><code>nap.nap_config.set_backend(\"numba\")\nnum_times = benchmark_threshold()\n</code></pre> <p>Calling with jax</p> <pre><code>nap.nap_config.set_backend(\"jax\")\njax_times = benchmark_threshold()\n</code></pre> <p>Out:</p> <pre><code>/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynapple/pynapple/core/utils.py:196: UserWarning: Converting 'start' to numpy.array. The provided array was of type 'ArrayImpl'.\n  warnings.warn(\n/mnt/home/gviejo/pynapple/pynapple/core/utils.py:196: UserWarning: Converting 'start' to numpy.array. The provided array was of type 'ArrayImpl'.\n  warnings.warn(\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynapple/pynapple/core/utils.py:196: UserWarning: Converting 'end' to numpy.array. The provided array was of type 'ArrayImpl'.\n  warnings.warn(\n/mnt/home/gviejo/pynapple/pynapple/core/utils.py:196: UserWarning: Converting 'end' to numpy.array. The provided array was of type 'ArrayImpl'.\n  warnings.warn(\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n/mnt/home/gviejo/pynapple/pynapple/core/utils.py:196: UserWarning: Converting 'start' to numpy.array. The provided array was of type 'ArrayImpl'.\n  warnings.warn(\n/mnt/home/gviejo/pynapple/pynapple/core/utils.py:196: UserWarning: Converting 'start' to numpy.array. The provided array was of type 'ArrayImpl'.\n  warnings.warn(\n/mnt/home/gviejo/pynapple/pynapple/core/utils.py:196: UserWarning: Converting 'end' to numpy.array. The provided array was of type 'ArrayImpl'.\n  warnings.warn(\n/mnt/home/gviejo/pynajax/src/pynajax/utils.py:131: UserWarning: Converting 'd' to jax.ndarray. The provided array was of type 'ndarray'.\n  return cast_to_jax(array, array_name, suppress_conversion_warnings)\n</code></pre> <p>Figure</p> <pre><code>plt.figure()\nfor arr, label in zip(\n    [num_times, jax_times],\n    [\"numba backend\", \"pynajax backend\"],\n    ):\n    plt.plot(arr[:, 0], arr[:, 1], \"o-\", label=label)\n    plt.fill_between(arr[:, 0], arr[:, 1] - arr[:, 2], arr[:, 1] + arr[:, 2], alpha=0.2)\nplt.legend()\nplt.xlabel(\"Number of Time points\")\nplt.ylabel(\"Time (s)\")\nplt.title(\"Threshold benchmark\")\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  8.563 seconds)</p> <p> Download Python source code: plot_benchmark_threshold.py</p> <p> Download Jupyter notebook: plot_benchmark_threshold.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"reference/SUMMARY/","title":"Code References","text":"<ul> <li>pynajax<ul> <li>jax_core_bin_average</li> <li>jax_core_convolve</li> <li>jax_core_threshold</li> <li>jax_process_filtering</li> <li>jax_process_perievent</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/pynajax/","title":"Pynajax","text":"<ul> <li>jax_core_bin_average</li> <li>jax_core_convolve</li> <li>jax_core_threshold</li> <li>jax_process_filtering</li> <li>jax_process_perievent</li> <li>utils</li> </ul>"},{"location":"reference/pynajax/jax_core_bin_average/","title":"Jax core bin average","text":""},{"location":"reference/pynajax/jax_core_bin_average/#pynajax.jax_core_bin_average.bin_average","title":"<code>bin_average(time_array, data_array, starts, ends, binsize)</code>","text":"<p>Perform bin-averaging of data array based on time array within specified epochs.</p> <p>Parameters:</p> Name Type Description Default <code>time_array</code> <code>ndarray</code> <p>Array of time points.</p> required <code>data_array</code> <code>ndarray</code> <p>Multidimensional data array to be averaged, where the first dimension matches time_array.</p> required <code>starts</code> <code>ndarray</code> <p>Start times of the epochs.</p> required <code>ends</code> <code>ndarray</code> <p>End times of the epochs.</p> required <code>binsize</code> <code>float</code> <p>Size of each bin.</p> required <p>Returns:</p> Name Type Description <code>time_array_new</code> <code>ndarray</code> <p>New time array corresponding to the bin centers.</p> <code>data_array_new</code> <code>ndarray</code> <p>New data array containing the averaged values.</p> Source code in <code>src/pynajax/jax_core_bin_average.py</code> <pre><code>def bin_average(time_array, data_array, starts, ends, binsize):\n    \"\"\"\n    Perform bin-averaging of data array based on time array within specified epochs.\n\n    Parameters\n    ----------\n    time_array : numpy.ndarray\n        Array of time points.\n    data_array : jax.numpy.ndarray\n        Multidimensional data array to be averaged, where the first dimension matches time_array.\n    starts : numpy.ndarray\n        Start times of the epochs.\n    ends : numpy.ndarray\n        End times of the epochs.\n    binsize : float\n        Size of each bin.\n\n    Returns\n    -------\n    time_array_new : jax.numpy.ndarray\n        New time array corresponding to the bin centers.\n    data_array_new : jax.numpy.ndarray\n        New data array containing the averaged values.\n    \"\"\"\n    if not isinstance(data_array, jnp.ndarray):\n        data_array = jnp.asarray(data_array)\n\n    # Calculate bin edges and identify time points within epochs for averaging.\n    ix, edges, in_epoch = _get_bin_edges(time_array, starts, ends, binsize=binsize)\n\n    # Digitize time points to find corresponding bins, adjusting indices to be 0-based.\n    bins = np.digitize(time_array[ix], edges) - 1\n    average = jit_average(bins, data_array[ix], edges)\n\n    # Create a new time array with bin centers, and filter by in-epoch bins.\n    time_array_new = edges[:-1] + binsize / 2\n    return time_array_new[in_epoch], average[in_epoch]\n</code></pre>"},{"location":"reference/pynajax/jax_core_convolve/","title":"Jax core convolve","text":"<p>Vectorized one-dimensional convolution.</p>"},{"location":"reference/pynajax/jax_core_convolve/#pynajax.jax_core_convolve.convolve_epoch","title":"<code>convolve_epoch(data, kernel)</code>","text":"<p>Convolve a single continuous temporal epoch.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(Tsd, TsdFrame, TsdTensor)</code> <p>Pynapple timeseries object with data to be convolved</p> required <code>kernel</code> <code>(ndarray, ndarray)</code> <p>1-D or 2-D array with kernel(s) to be used for convolution. First dimension is assumed to be time.</p> required <p>Returns:</p> Type Description <code>(Tsd, TsdFrame, TsdTensor)</code> <p>Pynapple timeseries object with convolved data. If kernel is a 1-D array, the dimensions of the input data are retained. If kernel is a 2-D array,  another (last) dimension is added to store convolution with every column of kernels.</p> Source code in <code>src/pynajax/jax_core_convolve.py</code> <pre><code>@jax.jit\ndef convolve_epoch(data, kernel):\n    \"\"\"Convolve a single continuous temporal epoch.\n\n    Parameters\n    ----------\n    data : pynapple.Tsd, pynapple.TsdFrame, pynapple.TsdTensor\n        Pynapple timeseries object with data to be convolved\n    kernel : numpy.ndarray, jax.numpy.ndarray\n        1-D or 2-D array with kernel(s) to be used for convolution.\n        First dimension is assumed to be time.\n\n    Returns\n    -------\n    pynapple.Tsd, pynapple.TsdFrame, pynapple.TsdTensor\n        Pynapple timeseries object with convolved data. If kernel\n        is a 1-D array, the dimensions of the input data are retained.\n        If kernel is a 2-D array,  another (last) dimension is added to\n        store convolution with every column of kernels.\n    \"\"\"\n    if kernel.ndim == 1:\n        data = _jit_tree_convolve_1d_kernel(data, kernel)\n    else:\n        data = _jit_tree_convolve_2d_kernel(data, kernel)\n    return data\n</code></pre>"},{"location":"reference/pynajax/jax_core_convolve/#pynajax.jax_core_convolve.convolve_intervals","title":"<code>convolve_intervals(time_array, data_array, starts, ends, kernel, trim='both')</code>","text":"<p>Convolve over the first dimension.</p> <p>Convolve over the first dimension, vectorizing on every dimension of data, with every column of kernel.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(Tsd, TsdFrame, TsdTensor)</code> <p>Pynapple timeseries object with data to be convolved</p> required <code>kernel</code> <code>(ndarray, ndarray)</code> <p>1-D or 2-D array with kernel(s) to be used for convolution. First dimension is assumed to be time.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Pynapple timeseries object with convolved data. If kernel is a 1-D array, the dimensions of the input data are retained. If kernel is a 2-D array, another (last) dimension is added to store convolution with every column of kernels.</p> Source code in <code>src/pynajax/jax_core_convolve.py</code> <pre><code>def convolve_intervals(time_array, data_array, starts, ends, kernel, trim=\"both\"):\n    \"\"\"Convolve over the first dimension.\n\n    Convolve over the first dimension, vectorizing on every dimension of data,\n    with every column of kernel.\n\n    Parameters\n    ----------\n    data : pynapple.Tsd, pynapple.TsdFrame, pynapple.TsdTensor\n        Pynapple timeseries object with data to be convolved\n    kernel : numpy.ndarray, jax.numpy.ndarray\n        1-D or 2-D array with kernel(s) to be used for convolution.\n        First dimension is assumed to be time.\n\n    Returns\n    -------\n    : jax.ndarray\n        Pynapple timeseries object with convolved data. If kernel is a\n        1-D array, the dimensions of the input data are retained. If kernel\n        is a 2-D array, another (last) dimension is added to store\n        convolution with every column of kernels.\n    \"\"\"\n    idx_start, idx_end = _get_idxs(time_array, starts, ends)\n    extra = _get_trim_idx(0, kernel.shape[0], trim)\n    extra = (extra[0], extra[1] + 1)\n\n    n = len(starts)\n    idx_start_shift = (\n        idx_start + np.arange(1, n + 1) * extra[0] + np.arange(0, n) * extra[1]\n    )\n    idx_end_shift = (\n        idx_end + np.arange(1, n + 1) * extra[0] + np.arange(0, n) * extra[1]\n    )\n\n    idx = _get_slicing(idx_start_shift, idx_end_shift)\n\n    tree = [data_array[start:end] for start, end in zip(idx_start, idx_end)]\n\n    if kernel.ndim == 1:\n        convolved_data = _jit_tree_convolve_1d_kernel(tree, kernel)\n    else:\n        convolved_data = _jit_tree_convolve_2d_kernel(tree, kernel)\n\n    return convolved_data[idx]\n</code></pre>"},{"location":"reference/pynajax/jax_core_convolve/#pynajax.jax_core_convolve.convolve","title":"<code>convolve(time_array, data_array, starts, ends, kernel, trim='both')</code>","text":"<p>One-dimensional convolution.</p> Source code in <code>src/pynajax/jax_core_convolve.py</code> <pre><code>def convolve(time_array, data_array, starts, ends, kernel, trim=\"both\"):\n    \"\"\"One-dimensional convolution.\"\"\"\n\n    if not isinstance(data_array, jnp.ndarray):\n        data_array = jnp.asarray(data_array)\n\n    # Perform convolution\n    if kernel.ndim == 0:\n        raise IOError(\n            \"Provide a kernel with at least 1 dimension, current kernel has 0 dimensions\"\n        )\n\n    if len(starts) == 1 and len(ends) == 1:\n        cut = _get_trim_idx(data_array.shape[0], kernel.shape[0], trim)\n        out = convolve_epoch(data_array, kernel)[cut[0] : cut[1]]\n    else:\n        out = convolve_intervals(time_array, data_array, starts, ends, kernel, trim)\n\n    return out\n</code></pre>"},{"location":"reference/pynajax/jax_core_threshold/","title":"Jax core threshold","text":""},{"location":"reference/pynajax/jax_core_threshold/#pynajax.jax_core_threshold.threshold","title":"<code>threshold(time_array, data_array, starts, ends, thr, method)</code>","text":"<p>Threshold function for pynajax</p> <p>Parameters:</p> Name Type Description Default <code>time_array</code> <code>ArrayLike</code> required <code>data_array</code> <code>ArrayLike</code> required <code>starts</code> <code>ArrayLike</code> required <code>ends</code> <code>ArrayLike</code> required <code>thr</code> <code>Number</code> required <code>method</code> <code>string</code> required <p>Returns:</p> Type Description <code>tuple of ArrayLike</code> <p>Description</p> Source code in <code>src/pynajax/jax_core_threshold.py</code> <pre><code>def threshold(time_array, data_array, starts, ends, thr, method):\n    \"\"\"Threshold function for pynajax\n\n    Parameters\n    ----------\n    time_array : ArrayLike\n\n    data_array : ArrayLike\n\n    starts : ArrayLike\n\n    ends : ArrayLike\n\n    thr : Number\n\n    method : string\n\n\n    Returns\n    -------\n    tuple of ArrayLike\n        Description\n    \"\"\"\n    if not isinstance(data_array, jnp.ndarray):\n        data_array = jnp.asarray(data_array)\n\n    idx_start, idx_end = _get_idxs(time_array, starts, ends)\n    idx_slicing = _get_slicing(idx_start, idx_end)\n\n    data_array = data_array[idx_slicing]\n    time_array = time_array[idx_slicing]\n\n    if method == \"above\":\n        ix = data_array &gt; thr\n    elif method == \"below\":\n        ix = data_array &lt; thr\n    elif method == \"aboveequal\":\n        ix = data_array &gt;= thr\n    elif method == \"belowequal\":\n        ix = data_array &lt;= thr\n\n    ix2 = jnp.diff(ix * 1)\n\n    new_starts = (\n        time_array[1:][ix2 == 1]\n        - (time_array[1:][ix2 == 1] - time_array[0:-1][ix2 == 1]) / 2\n    )\n    new_ends = (\n        time_array[0:-1][ix2 == -1]\n        + (time_array[1:][ix2 == -1] - time_array[0:-1][ix2 == -1]) / 2\n    )\n\n    if ix[0]:  # First element to keep as start\n        new_starts = jnp.hstack((jnp.array([time_array[0]]), new_starts))\n    if ix[-1]:  # last element to keep as end\n        new_ends = jnp.hstack((new_ends, jnp.array([time_array[-1]])))\n\n    return time_array[ix], data_array[ix], new_starts, new_ends\n</code></pre>"},{"location":"reference/pynajax/jax_process_filtering/","title":"Jax process filtering","text":""},{"location":"reference/pynajax/jax_process_filtering/#pynajax.jax_process_filtering.jax_sosfiltfilt","title":"<code>jax_sosfiltfilt(sos, time_array, data_array, starts, ends)</code>","text":"<p>Apply forward-backward filtering using a second-order section (SOS) filter.</p> <p>This function applies an SOS filter to the data array in both forward and reverse directions, which results in zero-phase filtering.</p> <p>Parameters:</p> Name Type Description Default <code>sos</code> <code>ndarray</code> <p>Array of second-order filter coefficients in the 'sos' format, with shape (n_sections, 6).</p> required <code>time_array</code> <code>ndarray</code> <p>The time array corresponding to the data, with shape (n_samples,).</p> required <code>data_array</code> <code>ndarray</code> <p>The data array to be filtered, with shape (n_samples, ...).</p> required <code>starts</code> <code>ndarray</code> <p>Array of start indices for the epochs in the data array.</p> required <code>ends</code> <code>ndarray</code> <p>Array of end indices for the epochs in the data array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The zero-phase filtered data array, with the same shape as the input data array.</p> Source code in <code>src/pynajax/jax_process_filtering.py</code> <pre><code>def jax_sosfiltfilt(sos, time_array, data_array, starts, ends):\n    \"\"\"\n    Apply forward-backward filtering using a second-order section (SOS) filter.\n\n    This function applies an SOS filter to the data array in both forward and reverse directions,\n    which results in zero-phase filtering.\n\n    Parameters\n    ----------\n    sos : np.ndarray\n        Array of second-order filter coefficients in the 'sos' format, with shape (n_sections, 6).\n    time_array : np.ndarray\n        The time array corresponding to the data, with shape (n_samples,).\n    data_array : jnp.ndarray\n        The data array to be filtered, with shape (n_samples, ...).\n    starts : np.ndarray\n        Array of start indices for the epochs in the data array.\n    ends : np.ndarray\n        Array of end indices for the epochs in the data array.\n\n    Returns\n    -------\n    : jnp.ndarray\n        The zero-phase filtered data array, with the same shape as the input data array.\n    \"\"\"\n\n    original_shape = data_array.shape\n    data_array = data_array.reshape(data_array.shape[0], -1)\n\n    # same default padding as scipy.sosfiltfilt (\"pad\" method and \"odd\" padtype).\n    n_sections = sos.shape[0]\n    ntaps = 2 * n_sections + 1\n    ntaps -= min((sos[:, 2] == 0).sum(), (sos[:, 5] == 0).sum())\n    pad_num = 3 * ntaps\n\n    ext, ix_start_pad, ix_end_pad, ix_data = _odd_ext_multiepoch(pad_num, time_array, data_array, starts, ends)\n\n    # get the start/end index of each epoch after padding\n    ix_start_ep = np.hstack((ix_start_pad[0], ix_start_pad[1:-1] + pad_num))\n    ix_end_ep = np.hstack((ix_start_ep[1:], ix_end_pad[-1]))\n\n    zi = signal.sosfilt_zi(sos)\n\n    # this braodcast has shape (*zi.shape, data_array.shape[1], len(ix_start_pad))\n    z0 = zi[..., jnp.newaxis, jnp.newaxis] * ext.T[jnp.newaxis, jnp.newaxis, ..., ix_start_ep]\n\n    if len(starts) &gt; 1:\n        # multi epoch case augmenting with nans.\n        aug_data, ix_orig, ix_shift, idx_start_shift, idx_end_shift = _insert_constant(\n            ix_start_ep, ix_end_ep, ext, window_size=1, const=np.nan\n        )\n\n        # grab the next initial condition, increase the epoch counter\n        nan_func = lambda ep_num, x: (ep_num + 1, x[..., ep_num + 1])\n    else:\n        # single epoch, no augmentation\n        nan_func = lambda ep_num, x: (ep_num + 1, x[..., 0])\n        aug_data = ext\n        idx_start_shift = ix_start_ep\n        idx_end_shift = ix_end_ep\n        ix_shift = slice(None)\n\n\n    # call forward recursion\n    out = _vmap_recursion_sos(aug_data, sos, z0, nan_func)\n\n    # reverse time axis\n    irev = _revert_epochs(idx_start_shift, idx_end_shift)\n    out = out.at[ix_shift].set(out[irev])\n\n    # compute new init cond\n    z0 = zi[..., jnp.newaxis, jnp.newaxis] * out.T[jnp.newaxis, jnp.newaxis, ..., idx_start_shift]\n\n    # call backward recursion\n    out = _vmap_recursion_sos(out, sos, z0, nan_func)\n\n    # re-flip axis\n    out = out.at[ix_shift].set(out[irev])\n\n    # remove nans and padding\n    out = out[ix_shift][ix_data]\n\n    return out.reshape(original_shape)\n</code></pre>"},{"location":"reference/pynajax/jax_process_perievent/","title":"Jax process perievent","text":""},{"location":"reference/pynajax/jax_process_perievent/#pynajax.jax_process_perievent.event_trigger_average","title":"<code>event_trigger_average(time_target_array, count_array, time_array, data_array, starts, ends, windows, binsize, batch_size)</code>","text":"<p>Main function to call for event-triggered averages (ETA) across multiple epochs. This function assumes count array and data array have been restricted before.</p> <p>Parameters:</p> Name Type Description Default <code>time_target_array</code> <code>ArrayLike</code> <p>Timestamps array of counts</p> required <code>count_array</code> <code>ArrayLike</code> <p>Count array of events</p> required <code>time_array</code> <code>ArrayLike</code> <p>Timestamps of data. Can be lower or above sampling rate of time_array</p> required <code>data_array</code> <code>ArrayLike</code> <p>Data to average at event</p> required <code>starts</code> <code>ArrayLike</code> <p>Start times of the epochs over which the STA is computed.</p> required <code>ends</code> <code>ArrayLike</code> <p>End times of the epochs, corresponding to each start time.</p> required <code>windows</code> <code>tuple of int</code> <p>The number of time steps to include before and after each event for averaging.</p> required <code>binsize</code> <code>float</code> <p>The bin size. Used by <code>bin_average</code>.</p> required <code>batch_size</code> <code>int</code> <p>Number of elements to process in each batch.</p> required <p>Returns:</p> Type Description <code>jnp.ndarray :</code> <p>The combined STA calculated across all specified epochs.</p> Source code in <code>src/pynajax/jax_process_perievent.py</code> <pre><code>def event_trigger_average(\n    time_target_array,\n    count_array,\n    time_array,\n    data_array,\n    starts,\n    ends,\n    windows,\n    binsize,\n    batch_size,\n):\n    \"\"\"\n    Main function to call for event-triggered averages (ETA) across multiple epochs.\n    This function assumes count array and data array have been restricted before.\n\n    Parameters\n    ----------\n    time_target_array : ArrayLike\n        Timestamps array of counts\n    count_array : ArrayLike\n        Count array of events\n    time_array : ArrayLike\n        Timestamps of data. Can be lower or above sampling rate of time_array\n    data_array : ArrayLike\n        Data to average at event\n    starts : ArrayLike\n        Start times of the epochs over which the STA is computed.\n    ends : ArrayLike\n        End times of the epochs, corresponding to each start time.\n    windows : tuple of int\n        The number of time steps to include before and after each event for averaging.\n    binsize : float\n        The bin size. Used by `bin_average`.\n    batch_size : int, optional\n        Number of elements to process in each batch.\n\n    Returns\n    -------\n    jnp.ndarray :\n        The combined STA calculated across all specified epochs.\n\n    \"\"\"\n    # Need to bring data_target_array to same shape as count_array\n    # bin_average\n    if count_array.shape[0] &lt; data_array.shape[0]:\n        time_array, data_array = bin_average(\n            time_array, data_array, starts, ends, binsize\n        )\n    # fill_forward\n    else:\n        data_array = _fill_forward(\n            time_target_array, time_array, data_array, starts, ends\n        )\n\n    idx_start, idx_end = _get_idxs(time_target_array, starts, ends)\n    idx_start_shift, idx_end_shift = _get_shifted_indices(\n        idx_start, idx_end, np.sum(windows) + 1\n    )\n\n    # get the indices for setting elements\n    ix_orig = _get_slicing(idx_start, idx_end)\n    ix_shift = _get_slicing(idx_start_shift, idx_end_shift)\n\n    # define larger array\n    tot_size = ix_shift[-1] - ix_shift[0] + 1\n\n    shape = data_array.shape\n    if data_array.ndim == 1:\n        data_array = np.expand_dims(data_array, -1)\n    else:\n        data_array = data_array.reshape(shape[0], -1)\n\n    num_full_batches = np.maximum(1, data_array.shape[1] // batch_size)\n    batch_size = np.minimum(data_array.shape[1], batch_size)\n    carry = 0\n\n    tot_count = jnp.sum(count_array, 0)\n\n    count_array = (\n        jnp.full((tot_size, *count_array.shape[1:]), np.nan)\n        .at[ix_shift]\n        .set(count_array[ix_orig])\n    )\n    count_array = pad_and_roll(count_array, windows)\n\n    def scan_fn(carry, x):\n        slc = jax.lax.dynamic_slice(\n            data_array, (0, carry), (data_array.shape[0], batch_size)\n        )\n        slc = (\n            jnp.full((tot_size, *slc.shape[1:]), np.nan).at[ix_shift].set(slc[ix_orig])\n        )\n        batch_result = _dot_prod_feature(count_array, slc)\n        return carry + batch_size, batch_result\n\n    _, res = jax.lax.scan(scan_fn, carry, None, length=num_full_batches)\n\n    res = jnp.transpose(res, (1, 2, 0, 3))  # move features at the end\n    res = res.reshape(*res.shape[:-2], -1)  # flatten features\n\n    extra_elements = data_array.shape[1] % batch_size\n    if extra_elements:\n        # compute residual slice\n        slc = data_array[:, -extra_elements:]\n        slc = (\n            jnp.full((tot_size, *slc.shape[1:]), np.nan).at[ix_shift].set(slc[ix_orig])\n        )\n        resid = _dot_prod_feature(count_array, slc)\n        # resid = resid.transpose(1, 2, 0).reshape(*res.shape[:-1], -1)\n        res = np.concatenate([res, resid], axis=2)\n\n    # reshape back to original\n    res = res.reshape((np.sum(windows) + 1, count_array.shape[-1], *shape[1:]))\n\n    res = jnp.apply_along_axis(jnp.divide, 1, res, tot_count)\n\n    return res\n</code></pre>"},{"location":"reference/pynajax/jax_process_perievent/#pynajax.jax_process_perievent.perievent_continuous","title":"<code>perievent_continuous(data_array, N_w, N_target, slice_idx, w_starts)</code>","text":"<p>Extract data from data array.</p> <p>Parameters:</p> Name Type Description Default <code>data_array</code> <code>ArrayLike</code> <p>The jax array to extract the data</p> required <code>N_w</code> <code>int</code> <p>window size</p> required <code>N_target</code> <code>int</code> <p>Number of reference time points</p> required <code>slice_idx</code> <code>ArrayLike</code> <p>2-d numpy array of size (N_target, 2). Each row is the start and end of the slice</p> required <code>w_starts</code> <code>ArrayLike</code> <p>1-d numpy array of size (N_target,). Whether to trim the window on the left when slicing</p> required Source code in <code>src/pynajax/jax_process_perievent.py</code> <pre><code>def perievent_continuous(data_array, N_w, N_target, slice_idx, w_starts):\n    \"\"\"\n    Extract data from data array.\n\n    Parameters\n    ----------\n    data_array : ArrayLike\n        The jax array to extract the data\n    N_w : int\n        window size\n    N_target : int\n        Number of reference time points\n    slice_idx : ArrayLike\n        2-d numpy array of size (N_target, 2). Each row is the start and end of the slice\n    w_starts : ArrayLike\n        1-d numpy array of size (N_target,). Whether to trim the window on the left when slicing\n    \"\"\"\n\n    if not isinstance(data_array, jnp.ndarray):\n        data_array = jnp.asarray(data_array)\n\n    new_data_array = jnp.full((N_w, N_target, *data_array.shape[1:]), jnp.nan)\n\n    w_sizes = slice_idx[:, 1] - slice_idx[:, 0]  # Different sizes\n\n    all_w_sizes = np.unique(w_sizes)\n    all_w_start = np.unique(w_starts)\n\n    for w_size in all_w_sizes:\n        for w_start in all_w_start:\n            col_idx = w_sizes == w_size\n            new_idx = np.zeros((w_size, np.sum(col_idx)), dtype=int)\n            for i, tmp in enumerate(slice_idx[col_idx]):\n                new_idx[:, i] = np.arange(tmp[0], tmp[1])\n\n            new_data_array = new_data_array.at[w_start : w_start + w_size, col_idx].set(\n                data_array[new_idx]\n            )\n\n    return new_data_array\n</code></pre>"},{"location":"reference/pynajax/utils/","title":"Utils","text":""},{"location":"reference/pynajax/utils/#pynajax.utils.is_array_like","title":"<code>is_array_like(obj)</code>","text":"<p>Check if an object is array-like.</p> <p>This function determines if an object has array-like properties. An object is considered array-like if it has attributes typically associated with arrays (such as <code>.shape</code>, <code>.dtype</code>, and <code>.ndim</code>), supports indexing, and is iterable.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object to check for array-like properties.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the object is array-like, False otherwise.</p> Notes <p>This function uses a combination of checks for attributes (<code>shape</code>, <code>dtype</code>, <code>ndim</code>), indexability, and iterability to determine if the given object behaves like an array. It is designed to be flexible and work with various types of array-like objects, including but not limited to NumPy arrays and JAX arrays. However, it may not be full proof for all possible array-like types or objects that mimic these properties without being suitable for numerical operations.</p> Source code in <code>src/pynajax/utils.py</code> <pre><code>def is_array_like(obj):\n    \"\"\"\n    Check if an object is array-like.\n\n    This function determines if an object has array-like properties.\n    An object is considered array-like if it has attributes typically associated with arrays\n    (such as `.shape`, `.dtype`, and `.ndim`), supports indexing, and is iterable.\n\n    Parameters\n    ----------\n    obj : object\n        The object to check for array-like properties.\n\n    Returns\n    -------\n    bool\n        True if the object is array-like, False otherwise.\n\n    Notes\n    -----\n    This function uses a combination of checks for attributes (`shape`, `dtype`, `ndim`),\n    indexability, and iterability to determine if the given object behaves like an array.\n    It is designed to be flexible and work with various types of array-like objects, including\n    but not limited to NumPy arrays and JAX arrays. However, it may not be full proof for all\n    possible array-like types or objects that mimic these properties without being suitable for\n    numerical operations.\n\n    \"\"\"\n    # Check for array-like attributes\n    has_shape = hasattr(obj, \"shape\")\n    has_dtype = hasattr(obj, \"dtype\")\n    has_ndim = hasattr(obj, \"ndim\")\n\n    # Check for indexability (try to access the first element)\n    try:\n        obj[0]\n        is_indexable = True\n    except (TypeError, IndexError):\n        is_indexable = False\n\n    # Check for iterable property\n    try:\n        iter(obj)\n        is_iterable = True\n    except TypeError:\n        is_iterable = False\n\n    # not_tsd_type = not isinstance(obj, _AbstractTsd)\n\n    return (\n        has_shape\n        and has_dtype\n        and has_ndim\n        and is_indexable\n        and is_iterable\n        # and not_tsd_type\n    )\n</code></pre>"},{"location":"reference/pynajax/utils/#pynajax.utils.cast_to_jax","title":"<code>cast_to_jax(array, array_name, suppress_conversion_warnings=False)</code>","text":"<p>Convert an input array-like object to a jax Array.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>array_like</code> <p>The input object to convert. This can be any object that <code>np.asarray</code> is capable of converting to a jax array, such as lists, tuples, and other array-like objects.</p> required <code>array_name</code> <code>str</code> <p>The name of the variable that we are converting, printed in the warning message.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A jax Array representation of the input <code>values</code>. If <code>values</code> is already a jax Array, it is returned unchanged. Otherwise, a new jax Array is created and returned.</p> Warnings <p>A warning is issued if the input <code>values</code> is not already a jax Array, indicating that a conversion has taken place and showing the original type of the input.</p> Source code in <code>src/pynajax/utils.py</code> <pre><code>def cast_to_jax(array, array_name, suppress_conversion_warnings=False):\n    \"\"\"\n    Convert an input array-like object to a jax Array.\n\n\n    Parameters\n    ----------\n    array : array_like\n        The input object to convert. This can be any object that `np.asarray` is capable of\n        converting to a jax array, such as lists, tuples, and other array-like objects.\n    array_name : str\n        The name of the variable that we are converting, printed in the warning message.\n\n    Returns\n    -------\n    ndarray\n        A jax Array representation of the input `values`. If `values` is already a jax\n        Array, it is returned unchanged. Otherwise, a new jax Array is created and returned.\n\n    Warnings\n    --------\n    A warning is issued if the input `values` is not already a jax Array, indicating\n    that a conversion has taken place and showing the original type of the input.\n\n    \"\"\"\n    if not isinstance(array, jnp.ndarray) and not suppress_conversion_warnings:\n        original_type = type(array).__name__\n        warnings.warn(\n            f\"Converting '{array_name}' to jax.ndarray. The provided array was of type '{original_type}'.\",\n            UserWarning,\n            stacklevel=2,\n        )\n    return jnp.asarray(array)\n</code></pre>"},{"location":"reference/pynajax/utils/#pynajax.utils.convert_to_jax_array","title":"<code>convert_to_jax_array(array, array_name, suppress_conversion_warnings=False)</code>","text":"<p>Convert any array like object to jax Array.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ArrayLike</code> required <code>array_name</code> <code>str</code> <p>Array name if RuntimeError is raised or object is casted to numpy</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Jax array object</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If input can't be converted to jax array</p> Source code in <code>src/pynajax/utils.py</code> <pre><code>def convert_to_jax_array(array, array_name, suppress_conversion_warnings=False):\n    \"\"\"Convert any array like object to jax Array.\n\n    Parameters\n    ----------\n    array : ArrayLike\n\n    array_name : str\n        Array name if RuntimeError is raised or object is casted to numpy\n\n    Returns\n    -------\n    jax.Array\n        Jax array object\n\n    Raises\n    ------\n    RuntimeError\n        If input can't be converted to jax array\n    \"\"\"\n    if isinstance(array, Number):\n        return jnp.array([array])\n    elif isinstance(array, (list, tuple)):\n        return jnp.array(array)\n    elif isinstance(array, jnp.ndarray):\n        return array\n    elif isinstance(array, np.ndarray):\n        return cast_to_jax(array, array_name, suppress_conversion_warnings)\n    elif is_array_like(array):\n        return cast_to_jax(array, array_name, suppress_conversion_warnings)\n    else:\n        raise RuntimeError(\n            \"Unknown format for {}. Accepted formats are numpy.ndarray, list, tuple or any array-like objects.\".format(\n                array_name\n            )\n        )\n</code></pre>"},{"location":"reference/pynajax/utils/#pynajax.utils.pad_and_roll","title":"<code>pad_and_roll(count_array, windows, constant_value=np.nan)</code>","text":"<p>Pad and roll the input array to generate shifted versions of the array according to specified window size and padding direction.</p> <p>Parameters:</p> Name Type Description Default <code>count_array</code> <code>ArrayLike</code> <p>The input array to pad and roll. This is typically a count or spike array in neural data analysis.</p> required <code>windows</code> <code>tuple of int</code> <p>The number of steps to include in the window. This defines the extent of the rolling operation.</p> required <code>constant_value</code> <p>Padding constant</p> <code>nan</code> <p>Returns:</p> Type Description <code>ArrayLike</code> <p>A 2D array where each row represents the input array rolled by one step in the range defined by the window and padding type. Only the valid range (original data indices) is returned.</p> Notes <p>The function uses <code>np.nan</code> for padding, which may need to be considered in subsequent calculations. Depending on the analysis, handling of <code>np.nan</code> may be required to avoid statistical or computational errors.</p> Source code in <code>src/pynajax/utils.py</code> <pre><code>def pad_and_roll(count_array, windows, constant_value=np.nan):\n    \"\"\"\n    Pad and roll the input array to generate shifted versions of the array according\n    to specified window size and padding direction.\n\n    Parameters\n    ----------\n    count_array : ArrayLike\n        The input array to pad and roll. This is typically a count or spike array in\n        neural data analysis.\n    windows : tuple of int\n        The number of steps to include in the window. This defines the extent of the\n        rolling operation.\n    constant_value: float\n        Padding constant\n\n    Returns\n    -------\n    ArrayLike\n        A 2D array where each row represents the input array rolled by one step in\n        the range defined by the window and padding type. Only the valid range (original\n        data indices) is returned.\n\n    Notes\n    -----\n    The function uses `np.nan` for padding, which may need to be considered in subsequent\n    calculations. Depending on the analysis, handling of `np.nan` may be required to avoid\n    statistical or computational errors.\n    \"\"\"\n    n_samples = count_array.shape[0]\n    pad = lambda x: jnp.pad(\n        x, pad_width=(windows, (0, 0)), constant_values=constant_value\n    )\n    indices = jnp.arange(-windows[0], windows[1] + 1)[::-1]\n    idx = jnp.arange(windows[0], n_samples + windows[0])\n    roll = jax.vmap(lambda i: jnp.roll(pad(count_array), -i, axis=0))\n    return roll(indices)[:, idx]\n</code></pre>"}]}